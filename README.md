# Scala Application

## Pre Interview Setup
- Make sure you're able to compile the project.
  - Execute `sbt compile` in the terminal.
  - If something is not working, please ensure you've installed all items mentioned in the `## Project Setup` section.
- Make sure you're able to run tests.
  - Run Docker dependencies by executing `docker-compose up -d`.
  - Run tests by executing `sbt clean at:test`.

## Tasks
- Run the application (refer to the #### Using Acceptance Test section below). 
- Check the Swagger docs:
  - Open `http://localhost:APP_PORT/docs` in your browser.
  - Copy the OpenAPI definition to `https://editor.swagger.io/`.
- Try to use an endpoint that allows returning rates for a given currency code.
- Identify what is wrong with the implementation and fix it.
- Further tasks will be provided by the interviewer.

## Project Setup

This project uses Scala. The current version is declared in the build.sbt file, and you will want that installed. SDKMAN makes it easy:

- Install SDKMAN: https://sdkman.io/install.
- Find a Java SDK version via `sdk list java` and install it. For example: `sdk install java 11.0.4.hs-adpt`.
- Install sbt: `sdk install sbt`.
- Install Scala: `sdk install scala 2.13.3`.
For compatibility between different Scala and JDK versions, visit: https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html.

Import the project into IntelliJ IDEA (use Import, not just open, to save yourself a lot of trouble). We recommend using IntelliJ IDEA as your IDE.
When importing and setting up the JDK and Scala SDK, choose the distributions installed previously.
By default, SDKMAN puts them in: `/Users/<user_name>/.sdkman/candidates/java/11.0.4.hs-adpt` and `/Users/<user_name>/.sdkman/candidates/scala/2.13.3`.

If you encounter issues while resolving dependencies via sbt, navigate to sbt settings and check the use `sbt shell for imports` setting.

### Language and tools
- code is written in Scala, version 2.13.x (see `scalaVersion` in `build.sbt`)
- [sbt](https://www.scala-sbt.org/) is used for dependency management and packaging

#### Useful commands
SBT commands documentation: [https://www.scala-sbt.org/1.x/docs/](https://www.scala-sbt.org/1.x/docs/)
- Compile project: `sbt compile`
- Run tests:
  - Unit tests only: `sbt test`
  - Integration tests only: `sbt it:testOnly`
  - Acceptance tests only: `sbt it:testOnly`
  - All tests: `sbt at:test`
  - Run a single test: `sbt 'IntegrationTest / testOnly *TestHarnessConnectionsSpec'`
- Run code formatting: `sbt scalafmtAll`
- Generate an assembly JAR file with the application: `sbt clean compile assembly`
- For each command, you can add `clean` after `sbt` to ensure it will clean all previous build artifacts before running the given command.

### Libraries and frameworks
Main libraries we use in the project:
- [Akka HTTP](https://doc.akka.io/docs/akka-http/current/introduction.html) for creating HTTP web server backend and HTTP client backend
- [Tapir](https://tapir.softwaremill.com/en/latest/) for API description and specification
- [STTP](https://sttp.softwaremill.com/en/stable/) for HTTP client interface
- [Slick](https://scala-slick.org/docs/) for database access and generating in-code DB model representation
- [Circe](https://circe.github.io/circe/) for JSON serialization/deserialization
- [Flyway](https://flywaydb.org/) for database migrations

### Docker
We use docker to containerize the application:
- `Dockerfile` contains the recipe for building a docker image for the application from the `.jar` file produced by the sbt assembly process.
- `docker-compose.yml` contains the definition of the docker-compose service used to run application dependencies locally.

To run application dependencies locally using docker-compose, you can run the following command:
```
docker-compose up -d
```

#### Project structure
- `application` package contains the application entry point and application logic divided into domain-oriented sub-packages.
- `database` package contains all code related to database access and setup without actual application database capabilities.
  - `model` contains `Tables.scala` where you can find Slick representation of the tables declared in the Flyway migration.
- `http` package contains all code related to HTTP server and client setup.
- `logging` package contains all code related to logging setup.

## Development

### Relational Database Management

Schema migrations are handled via [Flyway](https://flywaydb.org/) and applied automatically by the service when it starts.
Migrations are located in `src/main/resources/com/evidentid/db/migrations` for SQL-based migrations. See the Flyway docs if you want to add programmatic migrations.

#### Slick

Slick table representation is defined in `com.evidentid.database.model.Tables.scala` file.

To check the query generated by Slick (e.g. to run EXPLAIN), you can use the `statements` definition:
```
    import com.evidentid.database.DatabaseProfile.api._

    val simpleQuery = Tables.Entities.filter(_.displayName === "testname")
    val simpleQueryStatements = simpleQuery.result.statements
    print(simpleQueryStatements)

    val compiledQuery = databaseManager.compiledQueryThatWeWantAnalyse(("arg1", "arg2"))
    val compiledQueryStatements = compiledQuery.result.statements
    print(compiledQueryStatements)
```

### Testing

Commands that can be used to run tests are listed in `Useful commands` section above.

Commands that can be used to run tests are listed in the `Useful commands` section above.

Use `docker-compose up -d` to start the PostgreSQL required for the Integration and Acceptance tests.

We can distinguish three kinds of tests:
- Acceptance tests (`AT`)
  - Tests that are testing the application end to end and are interacting with it using the exposed API.
  - Those tests should be placed in the `com/evidentid/application/test/acceptance` package inside the `src/it` directory.
  - All acceptance tests should extend `AcceptanceFeatureSpec`, which ensures that the application is started before the test and stopped after the test and provides a bunch of useful helpers.
- Integration tests (`IT`)
  - Tests that are testing services or bigger application parts and frequently rely on some runtime dependencies that are not mocked but provided, e.g., as Docker containers. Such tests shouldn't use stubs/mocks or use them only if no other options are possible.
  - Those tests should be placed in the `com/evidentid/application/test/integration` package inside the `src/it` directory.
  - All acceptance tests should extend `IntegrationSpec`, which ensures that required dependencies are available and provides a bunch of useful helpers.
- Unit tests (`UT`)
  - Quick tests that are testing exactly one thing in isolation. Dependencies are stubbed/mocked to focus only on core assertions.
  - Those tests should be placed inside the `src/test` directory in the package corresponding to the tested component.
  - All acceptance tests should extend `UnitSpec`, which provides a bunch of useful helpers and initializes all common instances, e.g., `ExecutionContext` or `ActorSystem`.

We completely fake out the interactions with upstream APIs for component integration testing using [Mountebank](http://www.mbtest.org/). It runs on Node.js and can be configured almost arbitrarily for that.

### Running application locally

#### Using Acceptance Test

In acceptance tests, we're creating a fully functional application instance.
All you need is:
- Run acceptance test.
- Print web server `appBinding` to get the web server port (it is dynamically assigned).
- Ensure that the test will not finish, e.g., by adding a long sleep in the test implementation.

To accomplish this, add the following snippet in any acceptance test (the easiest is to use `SwaggerDocsFeature`):
```scala
// get application webserver address to be able interact with API
println(appBinding)
// long sleep so test won't finish - in this time we're able to use application
Thread.sleep(100000000)
```
and run test, either:
- use intellij to run it in IDE
- execute `sbt 'AcceptanceTest / testOnly *SwaggerDocsFeature'` (replace name with correct test class name) in terminal

------------------------------------------------------------------------------------------------------------------------
## API
All application APIs should be included in the Swagger specification.
The Swagger specification is generated automatically based on Tapir endpoints definition (see `DocsRoute.scala` for more details).
The application exposes swagger-ui under the `/docs` path. To see the currently exposed API, please use `SwaggerDocsFeature`, where you will find instructions on how to retrieve the Swagger YAML.
